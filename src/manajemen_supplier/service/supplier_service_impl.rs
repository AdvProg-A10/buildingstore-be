// src/manajemen_supplier/service/supplier_service_impl.rs
use std::sync::Arc;
use async_trait::async_trait;
use sqlx::{Any, Pool, Error as SqlxError};
use chrono::Utc; // Needed for Utc::now()
use uuid::Uuid; // Needed for Uuid::new_v4()

use crate::manajemen_supplier::model::supplier::Supplier;
use crate::manajemen_supplier::repository::supplier_repository::SupplierRepository;
use crate::manajemen_supplier::service::supplier_notifier::SupplierNotifier;
use crate::manajemen_supplier::service::supplier_service::SupplierService;

pub struct SupplierServiceImpl {
    supplier_repo: Arc<dyn SupplierRepository>,
    dispatcher: Arc<dyn SupplierNotifier>,
}

impl SupplierServiceImpl {
    pub fn new(
        supplier_repo: Arc<dyn SupplierRepository>,
        dispatcher: Arc<dyn SupplierNotifier>,
    ) -> Self {
        Self { supplier_repo, dispatcher }
    }
}

#[async_trait]
impl SupplierService for SupplierServiceImpl {
    async fn save_supplier(
        &self,
        db_pool: Pool<Any>,
        name: String,
        jenis_barang: String,
        jumlah_barang: i32,
        resi: String,
    ) -> Result<Supplier, String> {
        let conn = db_pool.acquire().await
            .map_err(|e| format!("Service: Failed to acquire DB connection: {}", e))?;
        
        let supplier_to_save = Supplier {
            id: Uuid::new_v4().to_string(), // ID generated by service
            name,
            jenis_barang,
            jumlah_barang,
            resi,
            updated_at: Utc::now(), // Timestamp set by service
        };
        
        let saved_supplier = self.supplier_repo.save(supplier_to_save, conn).await
            .map_err(|e| format!("Service: Repository save error: {}", e))?;

        self.dispatcher.notify_supplier_saved(&saved_supplier).await;
        Ok(saved_supplier)
    }

    async fn update_supplier(
        &self,
        db_pool: Pool<Any>,
        id: String, // ID from path
        name: String,
        jenis_barang: String,
        jumlah_barang: i32,
        resi: String,
    ) -> Result<(), String> { // Current signature, controller re-fetches
        let conn = db_pool.acquire().await
            .map_err(|e| format!("Service: Failed to acquire DB connection: {}", e))?;
        
        // Option 1: Fetch existing to ensure it's there & preserve other fields not being updated
        // This requires find_by_id to be robust.
        // let mut existing_supplier = match self.supplier_repo.find_by_id(&id, conn_for_find).await {
        //     Ok(s) => s,
        //     Err(SqlxError::RowNotFound) => return Err("Service: Supplier not found for update.".to_string()),
        //     Err(e) => return Err(format!("Service: Error fetching supplier for update: {}", e)),
        // };
        // existing_supplier.name = name;
        // existing_supplier.jenis_barang = jenis_barang;
        // existing_supplier.jumlah_barang = jumlah_barang;
        // existing_supplier.resi = resi;
        // existing_supplier.updated_at = Utc::now();
        // self.supplier_repo.update(existing_supplier, conn).await... (repo update would take whole object)

        // Option 2: Construct supplier object with only updatable fields + ID and new timestamp
        // This assumes the repository's `update` method correctly handles partial updates
        // or updates all passed fields. Your current repo `update` updates all listed fields.
        let supplier_to_update = Supplier {
            id,
            name,
            jenis_barang,
            jumlah_barang,
            resi,
            updated_at: Utc::now(), // Timestamp set by service
        };
        
        self.supplier_repo.update(supplier_to_update, conn).await
            .map_err(|e| match e {
                SqlxError::RowNotFound => "Service: Supplier not found for update.".to_string(),
                _ => format!("Service: Repository update error: {}", e),
            })
        // If this returned Result<Supplier, String>, you could return the updated entity directly
        // And the controller wouldn't need to re-fetch.
    }

    async fn delete_supplier(&self, db_pool: Pool<Any>, id: &str) -> Result<(), String> {
        let conn = db_pool.acquire().await
            .map_err(|e| format!("Service: Failed to acquire DB connection: {}", e))?;

        self.supplier_repo.delete(id, conn).await
            .map_err(|e| match e {
                SqlxError::RowNotFound => "Service: Supplier not found for delete.".to_string(),
                _ => format!("Service: Repository delete error: {}", e),
            })
    }

    async fn get_supplier(&self, db_pool: Pool<Any>, id: &str) -> Result<Option<Supplier>, String> {
        let conn = match db_pool.acquire().await {
            Ok(c) => c,
            Err(e) => {
                eprintln!("[Service Error] Failed to acquire DB connection for get_supplier (ID: {}): {}", id, e);
                return Err(format!("Service: Failed to acquire DB connection: {}", e));
            }
        };
        match self.supplier_repo.find_by_id(id, conn).await {
            Ok(s) => Ok(Some(s)), // Repository find_by_id returns Result<Supplier, Error>
            Err(SqlxError::RowNotFound) => Ok(None),
            Err(e) => {
                eprintln!("[Service Error] Repository error fetching supplier by ID '{}': {}", id, e);
                Err(format!("Service: Repository error: {}", e))
            }
        }
    }
}